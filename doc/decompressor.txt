Let's try to decompress [97, 98, 257].
We need to find a convenient way to simulate algorithm.

Read 97.
It means that first prefix is "a".
Remote dictionary applied code 257 for "ax" (x is unknown symbol).

Read 98.
It means that next prefix is "a".
So remote dictionary applied code 257 for "ab".
Remote dictionary applied code 258 for "bx".

Read 257.
It means that next prefix is "ab" (from dictionary).
So remote dictionary applied code 258 for "ba".

Destination is "abab".

-----

Now let's try to decompress [97, 98, 258].

97 and 98 means the same.

Read 258.
There is no 258 in dictionary.
We know that remote dictionary applied code 258 for "bx".
So destination looks like "abbx".
But it means that remote dictionary applied code 258 for "bb".

Destination is "abbb".
This is the most complex part of decompression algorithm.
We need to clarify it in general case.

-----

We have current prefix "a...b".
We know that remote dictionary applied code "c" for "a...bx".

Than we read this code "c" from source.
It means that destination looks like "a...ba...bx".
So "a...bx" is "a...ba".
So we have two identical strings that intersects by first symbol "a".

"a...ba....."
      |
".....a...ba"

We read last used code + 1 (node code) from source, it is not available in current dictionary.
In this case next prefix equals to current prefix + first symbol of current prefix.

When will this situation be possible?
1. "a...ba...ba": current prefix code >= 257 and it equals to last used code.
2. "aa": current prefix code <= 255 and code equals to 257.

In all other cases we should be able to find all symbols for target code in dictionary.

-----

What operations are required for decompressor's dictionary?
1. Is code presented in dictionary?
2. Output code.
3. Store next code in dictionary by prefix code and first symbol of current code.

We don't need to find code by symbol sequence.

Compressor requires to maintain mapping between current code and next code.
The problem is that current code has many next codes.

Decompressor requires opposite mapping.
One current code has only one previous code.
It makes decompressor simple and it looks impossible to speed up it.
So we can use single implementation of dictionary.

-----

We need just one array for code mapping.
It can be named as "previous_codes".

Indexes of this array will be >= 257.
Values are previous codes.
Any code can be previous for other code except max code.
Max code (2 ** 16) - 1 can't be previous code.
So values will be between 0 and (2 ** 16) - 2.

Undefined previous code will be equal to (2 ** 16) - 1.
It is possible to use zero instead of max code as undefined previous code.
We need just to increase each previous code value by 1 (offset constant).
So we can use efficient calloc and memset for previous codes.

-----

We need a separate array to map between code and last symbol.
It can be named as "last_symbol_by_codes".

Indexes of this array will be >= 257.

We don't need to initialize or clear it.
Algorithm will access only initialized symbols.

-----

We have to write output in an opposite direction.
It is possible to use another array as output buffer.
It can be named as "output_buffer".

Let's imagine we compressed "aa..." data.
All codes will be equal to prev code + 'a' symbol.
So max length of buffer will be (2 ** 16) - 257.

We don't need to initialize or clear it.
Algorithm will access only initialized bytes.

-----

For example [97, 98, 257] -> "abab":

Previous codes:
0 (257) -> 98 (97)
1 (258) -> 0

Last symbol by codes:
0 (257) -> 'b'

Output buffer for 257 code:
ba

-----

How much memory will it consume?
Previous codes:       ((2 ** 16) - 257) * sizeof(code_t)
Last symbol by codes: (2 ** 16) - 257
Output buffer:        (2 ** 16) - 257
Total: ~ 216 KB

-----

PS If block mode is disabled we don't need clear code (256).
So we can move from 257 to 256.
