It is possible to speedup dictionary lookup.
We can store codes trie in single sparse array.

For example:
"a" (97) -> "c" (262)
         -> "b" (257)
         -> "a" (259) -> "c" (263)
                      -> "b" (260)
"b" (98) -> "a" (258)
"c" (99) -> "a" (261)

Codes:
...
97 ("a") * 256 + 97 ("a") -> 259
97 ("a") * 256 + 98 ("b") -> 257
97 ("a") * 256 + 99 ("c") -> 262
...
98 ("b") * 256 + 97 ("a") -> 258
...
99 ("c") * 256 + 97 ("a") -> 261
...
259 ("aa") * 256 + 98 ("b") -> 260
259 ("aa") * 256 + 99 ("c") -> 263
...

Indexes of this array are between 0 and (2 ** 16) * 256 - 1.
Values >= 257.

We can still use 0 constant as undefined next code.
This is cool, because calloc is faster than malloc + fill.

-----

How much memory will it consume?
((2 ** 16) * 256) * sizeof(code) ~ 33.5 MB
I think it is not a big deal when we need maximum performance.

Please use this algorithm when you have big amount of data > 50 MB.
